import{Scene as e,OrthographicCamera as n,WebGLRenderer as t,PlaneGeometry as o,Mesh as i,ShaderMaterial as l,Vector3 as a,Vector2 as r,Clock as s}from"https://unpkg.com/three@0.159.0/build/three.module.js";export default function d(d,{linesGradient:m,enabledWaves:v=["top","middle","bottom"],lineCount:u=[6],lineDistance:c=[5],topWavePosition:f,middleWavePosition:p,bottomWavePosition:b={x:2,y:-.7,rotate:-1},animationSpeed:g=1,interactive:x=!0,bendRadius:h=5,bendStrength:C=-.5,mouseDamping:L=.05,parallax:y=!0,parallaxStrength:w=.2,mixBlendMode:U="screen"}={}){if(!d)throw new Error("FloatingLines: container element is required");d.classList.add("floating-lines-container"),U&&(d.style.mixBlendMode=U);const E=new r(-1e3,-1e3),P=new r(-1e3,-1e3);let W=0,R=0;const G=new r(0,0),I=new r(0,0),S=e=>{if("number"==typeof u)return u;if(!v.includes(e))return 0;const n=v.indexOf(e);return u[n]??6},B=e=>{if("number"==typeof c)return c;if(!v.includes(e))return.1;const n=v.indexOf(e);return c[n]??.1},M=v.includes("top")?S("top"):0,D=v.includes("middle")?S("middle"):0,O=v.includes("bottom")?S("bottom"):0,T=v.includes("top")?.01*B("top"):.01,_=v.includes("middle")?.01*B("middle"):.01,z=v.includes("bottom")?.01*B("bottom"):.01,A=new e,F=new n(-1,1,1,-1,0,1);F.position.z=1;const K=new t({antialias:!0,alpha:!1});K.setPixelRatio(Math.min(window.devicePixelRatio||1,2)),K.domElement.style.width="100%",K.domElement.style.height="100%",d.appendChild(K.domElement);const k={iTime:{value:0},iResolution:{value:new a(1,1,1)},animationSpeed:{value:g},enableTop:{value:v.includes("top")},enableMiddle:{value:v.includes("middle")},enableBottom:{value:v.includes("bottom")},topLineCount:{value:M},middleLineCount:{value:D},bottomLineCount:{value:O},topLineDistance:{value:T},middleLineDistance:{value:_},bottomLineDistance:{value:z},topWavePosition:{value:new a(f?.x??10,f?.y??.5,f?.rotate??-.4)},middleWavePosition:{value:new a(p?.x??5,p?.y??0,p?.rotate??.2)},bottomWavePosition:{value:new a(b?.x??2,b?.y??-.7,b?.rotate??.4)},iMouse:{value:new r(-1e3,-1e3)},interactive:{value:x},bendRadius:{value:h},bendStrength:{value:C},bendInfluence:{value:0},parallax:{value:y},parallaxStrength:{value:w},parallaxOffset:{value:new r(0,0)},lineGradient:{value:Array.from({length:8},()=>new a(1,1,1))},lineGradientCount:{value:0}};if(m&&m.length>0){const e=m.slice(0,8);k.lineGradientCount.value=e.length,e.forEach((e,n)=>{const t=function(e){let n=e.trim();n.startsWith("#")&&(n=n.slice(1));let t=255,o=255,i=255;return 3===n.length?(t=parseInt(n[0]+n[0],16),o=parseInt(n[1]+n[1],16),i=parseInt(n[2]+n[2],16)):6===n.length&&(t=parseInt(n.slice(0,2),16),o=parseInt(n.slice(2,4),16),i=parseInt(n.slice(4,6),16)),new a(t/255,o/255,i/255)}(e);k.lineGradient.value[n].set(t.x,t.y,t.z)})}const j=new l({uniforms:k,vertexShader:"\nprecision highp float;\n\nvoid main() {\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n",fragmentShader:"\nprecision highp float;\n\nuniform float iTime;\nuniform vec3  iResolution;\nuniform float animationSpeed;\n\nuniform bool enableTop;\nuniform bool enableMiddle;\nuniform bool enableBottom;\n\nuniform int topLineCount;\nuniform int middleLineCount;\nuniform int bottomLineCount;\n\nuniform float topLineDistance;\nuniform float middleLineDistance;\nuniform float bottomLineDistance;\n\nuniform vec3 topWavePosition;\nuniform vec3 middleWavePosition;\nuniform vec3 bottomWavePosition;\n\nuniform vec2 iMouse;\nuniform bool interactive;\nuniform float bendRadius;\nuniform float bendStrength;\nuniform float bendInfluence;\n\nuniform bool parallax;\nuniform float parallaxStrength;\nuniform vec2 parallaxOffset;\n\nuniform vec3 lineGradient[8];\nuniform int lineGradientCount;\n\nconst vec3 BLACK = vec3(0.0);\nconst vec3 PINK  = vec3(233.0, 71.0, 245.0) / 255.0;\nconst vec3 BLUE  = vec3(47.0,  75.0, 162.0) / 255.0;\n\nmat2 rotate(float r) {\n  return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\nvec3 background_color(vec2 uv) {\n  vec3 col = vec3(0.0);\n\n  float y = sin(uv.x - 0.2) * 0.3 - 0.1;\n  float m = uv.y - y;\n\n  col += mix(BLUE, BLACK, smoothstep(0.0, 1.0, abs(m)));\n  col += mix(PINK, BLACK, smoothstep(0.0, 1.0, abs(m - 0.8)));\n  return col * 0.5;\n}\n\nvec3 getLineColor(float t, vec3 baseColor) {\n  if (lineGradientCount <= 0) {\n    return baseColor;\n  }\n\n  vec3 gradientColor;\n  \n  if (lineGradientCount == 1) {\n    gradientColor = lineGradient[0];\n  } else {\n    float clampedT = clamp(t, 0.0, 0.9999);\n    float scaled = clampedT * float(lineGradientCount - 1);\n    int idx = int(floor(scaled));\n    float f = fract(scaled);\n    int idx2 = min(idx + 1, lineGradientCount - 1);\n\n    vec3 c1 = lineGradient[idx];\n    vec3 c2 = lineGradient[idx2];\n    \n    gradientColor = mix(c1, c2, f);\n  }\n  \n  return gradientColor * 0.5;\n}\n\n  float wave(vec2 uv, float offset, vec2 screenUv, vec2 mouseUv, bool shouldBend) {\n  float time = iTime * animationSpeed;\n\n  float x_offset   = offset;\n  float x_movement = time * 0.1;\n  float amp        = sin(offset + time * 0.2) * 0.3;\n  float y          = sin(uv.x + x_offset + x_movement) * amp;\n\n  if (shouldBend) {\n    vec2 d = screenUv - mouseUv;\n    float influence = exp(-dot(d, d) * bendRadius); // radial falloff around cursor\n    float bendOffset = (mouseUv.y - screenUv.y) * influence * bendStrength * bendInfluence;\n    y += bendOffset;\n  }\n\n  float m = uv.y - y;\n  return 0.0175 / max(abs(m) + 0.01, 1e-3) + 0.01;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 baseUv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n  baseUv.y *= -1.0;\n  \n  if (parallax) {\n    baseUv += parallaxOffset;\n  }\n\n  vec3 col = vec3(0.0);\n\n  vec3 b = lineGradientCount > 0 ? vec3(0.0) : background_color(baseUv);\n\n  vec2 mouseUv = vec2(0.0);\n  if (interactive) {\n    mouseUv = (2.0 * iMouse - iResolution.xy) / iResolution.y;\n    mouseUv.y *= -1.0;\n  }\n  \n  if (enableBottom) {\n    for (int i = 0; i < bottomLineCount; ++i) {\n      float fi = float(i);\n      float t = fi / max(float(bottomLineCount - 1), 1.0);\n      vec3 lineCol = getLineColor(t, b);\n      \n      float angle = bottomWavePosition.z * log(length(baseUv) + 1.0);\n      vec2 ruv = baseUv * rotate(angle);\n      col += lineCol * wave(\n        ruv + vec2(bottomLineDistance * fi + bottomWavePosition.x, bottomWavePosition.y),\n        1.5 + 0.2 * fi,\n        baseUv,\n        mouseUv,\n        interactive\n      ) * 0.2;\n    }\n  }\n\n  if (enableMiddle) {\n    for (int i = 0; i < middleLineCount; ++i) {\n      float fi = float(i);\n      float t = fi / max(float(middleLineCount - 1), 1.0);\n      vec3 lineCol = getLineColor(t, b);\n      \n      float angle = middleWavePosition.z * log(length(baseUv) + 1.0);\n      vec2 ruv = baseUv * rotate(angle);\n      col += lineCol * wave(\n        ruv + vec2(middleLineDistance * fi + middleWavePosition.x, middleWavePosition.y),\n        2.0 + 0.15 * fi,\n        baseUv,\n        mouseUv,\n        interactive\n      );\n    }\n  }\n\n  if (enableTop) {\n    for (int i = 0; i < topLineCount; ++i) {\n      float fi = float(i);\n      float t = fi / max(float(topLineCount - 1), 1.0);\n      vec3 lineCol = getLineColor(t, b);\n      \n      float angle = topWavePosition.z * log(length(baseUv) + 1.0);\n      vec2 ruv = baseUv * rotate(angle);\n      ruv.x *= -1.0;\n      col += lineCol * wave(\n        ruv + vec2(topLineDistance * fi + topWavePosition.x, topWavePosition.y),\n        1.0 + 0.2 * fi,\n        baseUv,\n        mouseUv,\n        interactive\n      ) * 0.1;\n    }\n  }\n\n  fragColor = vec4(col, 1.0);\n}\n\nvoid main() {\n  vec4 color = vec4(0.0);\n  mainImage(color, gl_FragCoord.xy);\n  gl_FragColor = color;\n}\n"}),q=new o(2,2),N=new i(q,j);A.add(N);const H=new s,V=()=>{const e=d.clientWidth||1,n=d.clientHeight||1;K.setSize(e,n,!1);const t=K.domElement.width,o=K.domElement.height;k.iResolution.value.set(t,o,1)};V();const X="undefined"!=typeof ResizeObserver?new ResizeObserver(V):null;X&&X.observe(d);const Y=e=>{const n=K.domElement.getBoundingClientRect(),t=e.clientX-n.left,o=e.clientY-n.top,i=K.getPixelRatio();if(E.set(t*i,(n.height-o)*i),W=1,y){const e=n.width/2,i=n.height/2,l=(t-e)/n.width,a=-(o-i)/n.height;G.set(l*w,a*w)}},J=()=>{W=0};x&&(K.domElement.addEventListener("pointermove",Y),K.domElement.addEventListener("pointerleave",J));let Q=0;const Z=()=>{k.iTime.value=H.getElapsedTime(),x&&(P.lerp(E,L),k.iMouse.value.copy(P),R+=(W-R)*L,k.bendInfluence.value=R),y&&(I.lerp(G,L),k.parallaxOffset.value.copy(I)),K.render(A,F),Q=requestAnimationFrame(Z)};Z();return{destroy:()=>{cancelAnimationFrame(Q),X&&X.disconnect(),x&&(K.domElement.removeEventListener("pointermove",Y),K.domElement.removeEventListener("pointerleave",J)),q.dispose(),j.dispose(),K.dispose(),K.domElement.parentElement&&K.domElement.parentElement.removeChild(K.domElement)}}}